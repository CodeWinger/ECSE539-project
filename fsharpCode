module hw4

(* Assignment 4 *) (* Do not edit this line. *)
(* Student name: Mikambi Ng'ong'ola, Id Number: 260611078 *) (* Edit this line. *)

type typExp =
  | TypInt
  | TypVar of char
  | Arrow of typExp * typExp
  | Lst of typExp

type substitution = (char * typExp) list

(* check if a variable occurs in a term *)
let rec occurCheck (v: char) (tau: typExp) : bool = 
    match tau with
    | TypInt -> false
    | TypVar a -> if (v = a) then true else false
    | Arrow (a,b) -> (occurCheck v a) || (occurCheck v b)
    | Lst a -> occurCheck v a

(* substitute typExp tau1 for all occurrences of type variable v in typExp tau2 *)
let rec substitute (tau1 : typExp) (v : char) (tau2 : typExp) : typExp =
  match tau2 with
    | TypInt -> tau2
    | TypVar a -> if (v = a) then tau1 else tau2
    | Arrow (a,b) -> Arrow((substitute tau1 v a),(substitute tau1 v b))
    | Lst a -> Lst(substitute tau1 v a)

let applySubst (sigma: substitution) (tau: typExp) : typExp = 
    List.foldBack (fun (x,u) -> substitute u x) sigma tau
(* This is a one-line program *)

let rec unify (tau1: typExp) (tau2:typExp) : substitution =
    match tau1,tau2 with
    | TypInt,TypInt -> []
    | TypVar a,TypVar b -> if (a = b) then [] else [(a,tau2)]
    | Lst a, Lst b-> unifies [(a,b)]
    | Arrow(a,b),Arrow(c,d) -> unifies [(a,c);(b,d)]
    | (TypVar a,b) | (b,TypVar a) -> if (occurCheck a b) then failwith "Failed occurs check" else [(a,b)]
    | (TypInt,_) | (_,TypInt) -> failwith "Not unifiable"
    | (Arrow(a,b), Lst c) | (Lst c, Arrow(a,b)) ->  failwith "Clash in principal type constructor"
and unifies (s):substitution =
    match s with
    | [] -> []
    | (x,y) :: t -> let t2 = unifies t
                    let t1 = unify (applySubst t2 x) (applySubst t2 y)
                    t1 @ t2 
(* Use the following signals if unification is not possible:

 failwith "Clash in principal type constructor"
 failwith "Failed occurs check"
 failwith "Not unifiable"

*)

(*
> let te4 = Arrow(TypInt, Arrow(TypVar 'c', TypVar 'a'));;

val te4 : typExp = Prod (TypInt,Arrow (TypVar 'c',TypVar 'a'))

> let te3 = Arrow (TypVar 'a',Arrow (TypVar 'b',TypVar 'c'));;

val te3 : typExp = Arrow (TypVar 'a',Arrow (TypVar 'b',TypVar 'c'))

> unify te3 te4;;
val it : substitution = [('c', TypInt); ('b', TypVar 'c'); ('a', TypInt)]
> let result = it;;

val result : substitution = [('c', TypInt); ('b', TypVar 'c'); ('a', TypInt)]

> applySubst result te3;;
val it : typExp = Arrow (TypInt,Arrow (TypInt,TypInt))
> applySubst result te4;;
val it : typExp = Arrow (TypInt,Arrow (TypInt,TypInt))

*)
